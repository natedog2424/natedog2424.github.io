This small interactive program allows you to visualize the A-Star pathfinding algorithm on real streets anywhere in the world. Try it out in the embedded view above or click **live demo** to use the program fullscreen. Drag the slippy map interface to somewhere you would like to visualize pathfinding on and click the toggle pathfinding mode button. Wait for the streets to load in (this may take a minute on slow connections) and click any 2 points on the map to visualize pathfinding between them. Click anywhere to reset the map and try another route.

## Project Background
 The inspiration for this project came after I watched [this video](https://www.youtube.com/watch?v=CgW0HPHqFE8) by *ones and zeros* on YouTube. I was mesmerized by the visualization and how it showed how the A-Star algorithm works. I wanted to play with this and try it out on my local Arizona streets but unfortunately the video was a pre-rendered and the code was not available. I knew that I could implement this myself and figured it would be a good way to brush up on my data structures and algorithms knowledge so I got to work.

## Technical Implementation
The slippy map used to pick a frame for the algorithm is provided by the Â [Leaflet](https://leafletjs.com) and the map data is provided by the amazing [OpenStreetMap](http://www.openstreetmap.org/) project. All of the code for the demo is written in JavaScript and the roads are drawn to screen using the HTML canvas element.

#### Fetching the map data
When the user enters pathfinding mode, a query is made to the OpenStreetMap Overpass API requesting all ways (roads) with the highway key set to one of a few values (eg. Motorway, Primary, etc; based upon the level of detail required for the current zoom level) contained within the longitude and latitude bounds of the view. The overpass API then responds with an XML payload containing a list of every node that matches the query and a list of ways that connect the nodes. I then utilize the JavaScript DOMParser class deserialize the data into a list of node objects that contain latitude and longitude positions and a list of way objects that contain a list of each node that belongs to it.
#### Drawing the map
The map is drawn by looping over the list of ways and using the JavaScript canvas context to draw a line between every node in the way. By populating the lists of nodes in the way objects at the time of fetching the data, drawing each way is much faster. This worked great until I added the animations that fade the lines in and I realized that, depending on where the map was positioned, I was asking my computer to draw 50,000+ lines 30+ times a second and it was not happy.
#### Optimizations
The Overpass API enables you to specify the types of features you want to receive by providing key-value pairs. This allows you to filter nodes based on your preferences. For instance, when zoomed out, you can only request highways, and while when zoomed in, you can request every little residential road. This is great on a macro scale but unfortunately, you cannot ask for overpass to send you ways at a lower resolution so you are always given roads with very dense nodes. To overcome this challenge I set out to reduce unnecessary nodes without compromising on the visual quality of the map. In order to get an idea of how many nodes I would need to trim I first implemented the naive approach of simply deleting some percentage of the nodes from each way. I ensured to skip the first and last node of a way and then removing a node from a way was simply just removing a node's reference from the list of nodes in the given way. From my testing I discovered that I was able to remove a very high percentage of nodes without losing much visual fidelity on straight roads but I would start to notice some jagged lines on curved roads. As I expected, now that I trimmed out many nodes, the program was able to run with smooth animations. I knew that if I used an angle based simplification algorithm I could get these performance improvements without sacrificing the smoothness of the curved roads.
#### Angle based simplification
Simplifying the map data based on an angle threshold allows me to remove nodes which do not contribute much visually to the rendered map. The algorithm loops over every way and then every node in the given way (except for the starting and ending nodes since those are needed). If the current node has an edge count greater than 2, the node is a junction between multiple ways and therefore is needed so the loop is continued. The angle between the selected node and both of it's siblings is then calculated by deriving 2 vectors from the selected node to the siblings and then the angle between those vectors is calculated using the dot product and arc cosine. If the angle is less than some constant angle limit, the node is dissolved and it's siblings are connected. This algorithm proved to be very successful and allowed me to keep detail in important areas of the map while hitting my desired frame rate. When pathfinding the demo's starting position in London the number of nodes is reduced from 33,585 sent from Overpass to only 11,413 being rendered to screen. If you want to see the simplification working in the demo, you can open the developer console and the number of nodes is printed out as simplification iterations are being run. The current implementation of the algorithm works but still has a lot of room for improvement and I would like to revisit it at some point.

#### A-Star
I went into this project expecting the A-Star algorithm to be the main challenge however it actually proved fairly trivial to implement. The A-Star algorithm is essentially Dijkstra's algorithm with an additional heuristic function evaluated when weighting paths for exploration. The heuristic implemented in the demo is just the pythagorean distance to the selected sink node. I hope to add the option to view different heuristics in the future.

## Key Learnings
This project gave me a chance to re-visit and strengthen my understanding of Dijkstra's algorithm. I was able to augment my understanding with the A-Star heuristic function as well as explore how to deserialize real world data into structures that made implementing the algorithm much easier. I also enjoyed practicing iterative problem solving to tackle the optimization issue. Lastly, I got to use the JavaScript canvas element which I hadn't used too much before.